Index: gdm-2.30.5/daemon/gdm-display.c
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-display.c	2010-09-16 22:27:23.560059700 +0200
+++ gdm-2.30.5/daemon/gdm-display.c	2010-09-16 22:54:22.195561908 +0200
@@ -340,6 +340,32 @@ gdm_display_set_slave_bus_name (GdmDispl
         return ret;
 }
 
+static gboolean
+gdm_display_real_set_needs_respawn (GdmDisplay *display,
+                                    gboolean    respawn,
+                                    GError    **error)
+{
+        return TRUE;
+}
+
+gboolean
+gdm_display_set_needs_respawn (GdmDisplay *display,
+                               gboolean    respawn,
+                               GError    **error)
+{
+        gboolean ret;
+
+        g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
+
+        g_debug ("GdmDisplay: %s respawn on display %s", respawn?"Enabling":"Disabling", display->priv->x11_display_name);
+
+        g_object_ref (display);
+        ret = GDM_DISPLAY_GET_CLASS (display)->set_needs_respawn (display, respawn, error);
+        g_object_unref (display);
+
+        return ret;
+}
+
 static void
 gdm_display_real_get_timed_login_details (GdmDisplay *display,
                                           gboolean   *enabledp,
@@ -1139,6 +1165,7 @@ gdm_display_class_init (GdmDisplayClass
         klass->add_user_authorization = gdm_display_real_add_user_authorization;
         klass->remove_user_authorization = gdm_display_real_remove_user_authorization;
         klass->set_slave_bus_name = gdm_display_real_set_slave_bus_name;
+        klass->set_needs_respawn = gdm_display_real_set_needs_respawn;
         klass->get_timed_login_details = gdm_display_real_get_timed_login_details;
         klass->prepare = gdm_display_real_prepare;
         klass->manage = gdm_display_real_manage;
Index: gdm-2.30.5/daemon/gdm-display.h
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-display.h	2010-09-16 22:02:43.851563101 +0200
+++ gdm-2.30.5/daemon/gdm-display.h	2010-09-16 22:54:22.195561908 +0200
@@ -66,6 +66,9 @@ typedef struct
         gboolean (*set_slave_bus_name)        (GdmDisplay *display,
                                                const char *name,
                                                GError    **error);
+        gboolean (*set_needs_respawn)         (GdmDisplay *display,
+                                               gboolean    respawn,
+                                               GError    **error);
         gboolean (*prepare)                   (GdmDisplay *display);
         gboolean (*manage)                    (GdmDisplay *display);
         gboolean (*finish)                    (GdmDisplay *display);
@@ -150,6 +153,9 @@ gboolean            gdm_display_get_user
 gboolean            gdm_display_set_slave_bus_name             (GdmDisplay *display,
                                                                 const char *name,
                                                                 GError    **error);
+gboolean            gdm_display_set_needs_respawn              (GdmDisplay *display,
+                                                                gboolean    respawn,
+                                                                GError    **error);
 
 
 G_END_DECLS
Index: gdm-2.30.5/daemon/gdm-display.xml
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-display.xml	2010-09-16 22:02:43.835561766 +0200
+++ gdm-2.30.5/daemon/gdm-display.xml	2010-09-16 22:54:22.195561908 +0200
@@ -45,6 +45,9 @@
     <method name="SetSlaveBusName">
       <arg name="name" direction="in" type="s"/>
     </method>
+    <method name="SetNeedsRespawn">
+      <arg name="respawn" direction="in" type="b"/>
+    </method>
     <method name="GetTimedLoginDetails">
       <arg name="enabled" direction="out" type="b"/>
       <arg name="username" direction="out" type="s"/>
Index: gdm-2.30.5/daemon/gdm-simple-slave.c
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-simple-slave.c	2010-09-16 22:54:22.159562081 +0200
+++ gdm-2.30.5/daemon/gdm-simple-slave.c	2010-09-16 22:54:22.195561908 +0200
@@ -109,6 +109,9 @@ on_session_started (GdmSession       *se
 
         g_debug ("GdmSimpleSlave: session started %d", pid);
 
+        /* Respawn the display when the user session has finished */
+        gdm_slave_set_needs_respawn (GDM_SLAVE (slave), TRUE);
+
         /* Run the PreSession script. gdmslave suspends until script has terminated */
         username = gdm_session_direct_get_username (slave->priv->session);
         if (username != NULL) {
Index: gdm-2.30.5/daemon/gdm-slave.c
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-slave.c	2010-09-16 22:44:44.356058833 +0200
+++ gdm-2.30.5/daemon/gdm-slave.c	2010-09-16 22:57:58.667559881 +0200
@@ -600,6 +600,36 @@ gdm_slave_set_slave_bus_name (GdmSlave *
         return res;
 }
 
+gboolean
+gdm_slave_set_needs_respawn (GdmSlave *slave,
+                             gboolean  respawn)
+{
+        gboolean    res;
+        GError     *error;
+
+        /* Never, ever respawn a nested display */
+        respawn = FALSE;
+
+        error = NULL;
+        res = dbus_g_proxy_call (slave->priv->display_proxy,
+                                 "SetNeedsRespawn",
+                                 &error,
+                                 G_TYPE_BOOLEAN, respawn,
+                                 G_TYPE_INVALID,
+                                 G_TYPE_INVALID);
+
+        if (! res) {
+                if (error != NULL) {
+                        g_warning ("Failed to set respawn on parent display: %s", error->message);
+                        g_error_free (error);
+                } else {
+                        g_warning ("Failed to set respawn on parent display");
+                }
+        }
+
+        return res;
+}
+
 static gboolean
 gdm_slave_real_start (GdmSlave *slave)
 {
Index: gdm-2.30.5/daemon/gdm-slave.h
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-slave.h	2010-09-16 22:02:43.795560871 +0200
+++ gdm-2.30.5/daemon/gdm-slave.h	2010-09-16 22:54:22.199561508 +0200
@@ -72,6 +72,9 @@ gboolean            gdm_slave_add_user_a
 gboolean            gdm_slave_switch_to_user_session (GdmSlave   *slave,
                                                       const char *username);
 
+gboolean            gdm_slave_set_needs_respawn      (GdmSlave *slave,
+                                                      gboolean  respawn);
+
 gboolean            gdm_slave_connect_to_x11_display (GdmSlave   *slave);
 void                gdm_slave_set_busy_cursor        (GdmSlave   *slave);
 gboolean            gdm_slave_run_script             (GdmSlave   *slave,
Index: gdm-2.30.5/daemon/gdm-transient-display.c
===================================================================
--- gdm-2.30.5.orig/daemon/gdm-transient-display.c	2010-09-16 22:02:43.783564024 +0200
+++ gdm-2.30.5/daemon/gdm-transient-display.c	2010-09-16 22:54:22.199561508 +0200
@@ -45,7 +45,7 @@
 
 struct GdmTransientDisplayPrivate
 {
-        gpointer dummy;
+        gboolean needs_respawn;
 };
 
 enum {
@@ -86,6 +86,20 @@ gdm_transient_display_remove_user_author
 }
 
 static gboolean
+gdm_transient_display_set_needs_respawn (GdmDisplay *display,
+                                         gboolean    respawn,
+                                         GError    **error)
+{
+        g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
+
+        GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->set_needs_respawn (display, respawn, error);
+
+        GDM_TRANSIENT_DISPLAY (display)->priv->needs_respawn = respawn;
+
+        return TRUE;
+}
+
+static gboolean
 gdm_transient_display_manage (GdmDisplay *display)
 {
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
@@ -100,10 +114,24 @@ gdm_transient_display_finish (GdmDisplay
 {
         g_return_val_if_fail (GDM_IS_DISPLAY (display), FALSE);
 
-        GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->finish (display);
+        if (GDM_TRANSIENT_DISPLAY (display)->priv->needs_respawn) {
+                int status;
 
-        /* we don't restart/remanage transient displays */
-        gdm_display_unmanage (display);
+                /* If we were told to respawn, don't call parent's
+                   finish since we don't want to be put in the
+                   FINISHED state */
+
+                gdm_display_unmanage (display);
+
+                status = gdm_display_get_status (display);
+                if (status != GDM_DISPLAY_FAILED) {
+                        gdm_display_manage (display);
+                }
+        } else {
+                GDM_DISPLAY_CLASS (gdm_transient_display_parent_class)->finish (display);
+
+                gdm_display_unmanage (display);
+        }
 
         return TRUE;
 }
@@ -168,6 +196,7 @@ gdm_transient_display_class_init (GdmTra
         display_class->create_authority = gdm_transient_display_create_authority;
         display_class->add_user_authorization = gdm_transient_display_add_user_authorization;
         display_class->remove_user_authorization = gdm_transient_display_remove_user_authorization;
+        display_class->set_needs_respawn = gdm_transient_display_set_needs_respawn;
         display_class->manage = gdm_transient_display_manage;
         display_class->finish = gdm_transient_display_finish;
         display_class->unmanage = gdm_transient_display_unmanage;
